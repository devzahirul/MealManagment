# MealManage (Android)

[![CI](https://github.com/devzahirul/MealManagment/actions/workflows/ci.yml/badge.svg?branch=main)](https://github.com/devzahirul/MealManagment/actions/workflows/ci.yml?query=branch%3Amain)
<!-- The tests and coverage badges are generated by CI on the main branch. 
     They are served from the main branch so that they render on feature branches too. -->
![Tests](https://raw.githubusercontent.com/devzahirul/MealManagment/main/badges/tests.svg)
![Coverage](https://raw.githubusercontent.com/devzahirul/MealManagment/main/badges/coverage.svg)

Module coverage:

![Domain](https://raw.githubusercontent.com/devzahirul/MealManagment/main/badges/coverage-domain.svg)
![Core](https://raw.githubusercontent.com/devzahirul/MealManagment/main/badges/coverage-core.svg)
![Data](https://raw.githubusercontent.com/devzahirul/MealManagment/main/badges/coverage-data.svg)
![App](https://raw.githubusercontent.com/devzahirul/MealManagment/main/badges/coverage-app.svg)

MealManage is an Android app built with Kotlin and Jetpack Compose to help small groups track daily meals and shared costs. It uses Firebase Authentication and Cloud Firestore for sign‑in, storage, and realtime updates.

## Features

- Email/password sign‑in and sign‑up.
- Meals calendar per user with day badges and colors:
  - Yellow for current/future days with meals, green for past days with meals.
  - Tap a current/future day to edit your count.
  - Tap a past day to view all users’ counts.
  - Realtime updates with a resilient fallback to keep the calendar populated.
- Costs tracking: add costs, monthly totals, and per‑user breakdowns.
- Home dashboard:
  - Month total cost and computed meal rate (cost ÷ total meals).
  - Today’s meals (total and top users).
  - Month by user: costs, meals, expected vs actual (balance).
- Profile: set a display name and sign out.

## Tech Stack

- Kotlin, Jetpack Compose (Material 3)
- Firebase: Authentication, Cloud Firestore (KTX SDKs, BoM)
- Gradle Android Plugin 8.5, Kotlin 1.9, Compose BOM 2024.04.01
- Min SDK 24, Target/Compile SDK 34

## Architecture

Clean Architecture + MVVM with dependency inversion and a clear module boundary.

- core
  - Platform‑agnostic abstractions (no Android deps):
    - `DateProvider` (time source), dispatchers qualifiers `@IoDispatcher`, `@DefaultDispatcher`, `@MainDispatcher`.
- domain
  - Pure business layer (no Android/Firebase deps):
    - Models: `Meal`, `UserMeal`, `UserProfile`, `CostItem`, `UserId`.
    - `Result<T>` and `DomainError` sealed types.
    - Repository interfaces: `MealRepository`, `CostRepository`, `UserRepository`, `AuthRepository`.
    - Use cases: thin orchestration wrappers (e.g., `GetTotalMealsForRange`).
- data
  - Firebase implementations of repositories (Auth, Firestore):
    - All IO executed via injected `@IoDispatcher CoroutineDispatcher`.
    - Error mapping to `DomainError`.
    - DI bindings: `RepositoryModule` binds impls to domain interfaces.
- app
  - Presentation/UI (Jetpack Compose) and ViewModels (MVVM):
    - ViewModels depend on domain use cases and `DateProvider`.
    - DI providers: `CoreModule` provides `DateProvider` and `@IoDispatcher`.
    - Hilt ViewModels manage UI state and call use cases.

Dependency direction: app → domain (use cases) → data (through interfaces). core is used across layers for system abstractions.

Sequence example (monthly summary):
1) `HomeViewModel.refreshAll()`
2) Calls `GetTotalCostForRange` and `GetTotalMealsForRange`
3) Use cases call `CostRepository`/`MealRepository` (domain interfaces)
4) Data layer (Firebase) executes IO on `@IoDispatcher` and maps errors to `DomainError`
5) Domain `Result` bubbles back to ViewModel which updates `UiState`

## Project Structure

- `app/src/main/java/com/ugo/mhews/mealmanage/ui` — Compose screens
  - `HomeScreen.kt`, `MealScreen.kt`, `CostAddScreen.kt`, `ProfileScreen.kt`, `LoginScreen.kt`
- `app/src/main/java/com/ugo/mhews/mealmanage/data` — Repositories for Firebase access
  - `MealRepository.kt`, `CostRepository.kt`, `UserRepository.kt`, `AuthRepository.kt`, `FirestoreProvider.kt`
- `app/src/main/java/com/ugo/mhews/mealmanage/ui/theme` — Theme (Material 3 light color scheme)
- Firestore security and indexes: `firestore.rules`, `firestore.indexes.json`

### Modules
- `:core` — time/dispatchers abstractions and qualifiers
- `:domain` — models, Result/DomainError, repo interfaces, use cases
- `:data` — Firebase repository implementations, error mappers, Hilt binds
- `:app` — Compose UI, ViewModels, DI providers

### Visual Overview

```
 ┌──────────┐       ┌──────────┐       ┌────────┐       ┌────────────┐
 │  app     │  👉   │  domain  │  👉   │  data  │  👉   │  Firebase   │
 │ (UI +    │ uses  │ (use     │ uses  │ (repos │ hits │ Auth/Firestore
 │ ViewModel│ cases)│ cases +  │ repos │ + data │ REST │ via SDKs)   │
 │ layer)   │       │ contracts│       │sources)│       │             │
 └──────────┘       └──────────┘       └────────┘       └────────────┘
        ▲                ▲                ▲
        │                │                │
        └───── core abstractions (DateProvider, Dispatchers) ─────┘
```

Each arrow points one way—presentation depends on use cases, which depend on repository contracts, which are implemented by the data module. The core module supplies cross-cutting abstractions (time/dispatchers) without Android dependencies.

### Why it scales and stays testable

- **Explicit APIs:** Every capability is exposed through a dedicated use case (`domain/usecase`). This keeps ViewModels simple and makes features composable. Scaling the product means adding new use cases rather than touching shared repositories directly.
- **Pluggable data sources:** The data module separates repository logic from Firebase APIs via `AuthDataSource`, `MealDataSource`, `CostDataSource`, and `UserDataSource`. Swapping to a different backend only requires new data source implementations; the rest of the stack remains untouched.
- **Deterministic testing:** The domain and data layers have 100% line coverage enforced via `./gradlew koverVerify`. Because use cases depend on interfaces, we can inject fakes/stubs in unit tests (see `data/src/test/...` for examples) and fully validate behaviour without hitting the network.
- **Maintainability:** Responsibilities are isolated. Core abstractions remove Android dependencies from lower layers; DI modules (`app/di`, `data/di`) are the only places wiring happens. This makes refactors localized and keeps runtime configuration in one place.

### Use case walkthrough: “Refresh monthly dashboard”

1. `HomeViewModel.refreshAll()` (app layer) requests the current month range from `MonthRangeCalculator` (domain utility) and triggers two use cases: `GetTotalCostForRange` and `GetTotalMealsForRange`.
2. Each use case delegates to the appropriate repository (`CostRepository`, `MealRepository`) defined in the domain module. The ViewModel only receives `Result` objects and stays ignorant of Firebase implementation details.
3. The repositories in `data` call into their injected data sources (e.g., `FirebaseCostDataSource`). Errors are mapped to `DomainError` so the UI can render friendly messages without parsing exceptions.
4. Because the same use cases are reused elsewhere (e.g., by the user-level breakdown and today’s snapshot), logic stays consistent and reusable. Testing the flow is trivial: in unit tests we provide fake data sources returning deterministic values, and assert the ViewModel state updates without needing Firebase.

This layered approach means new features (say, exporting reports or supporting another backend) can be built by adding new use cases/data sources without breaking existing contracts, keeping the codebase scalable, testable, and maintainable.

## Firestore Data Model

- Users: `Users/{uid}`
  - Fields: `name: string`, `email: string`
- Meals by user (subcollection): `Meals/{uid}/days/{YYYY-MM-DD}`
  - Fields: `uid: string`, `date: string (YYYY-MM-DD)`, `count: number`
- Costs: `AddCost/{autoId}`
  - Fields: `uid: string`, `name: string`, `cost: number`, `timestamp: number (ms)`

Indexes (included):
- Collection group `days` — single‑field index on `date` (ASCENDING) for range queries.
- `AddCost` composite index on `(uid ASC, timestamp ASC)`.

## Prerequisites

- Android Studio (Hedgehog or newer) with Android SDK 34.
- Java toolchain via Android Studio (project uses Java 8 bytecode + desugaring).
- A Firebase project with Authentication and Firestore enabled.
- Firebase CLI if you want to deploy rules/indexes from the repo.

## Setup

1) Clone the repo
- `git clone https://github.com/devzahirul/MealManagment.git`
- Open in Android Studio.

2) Firebase project and app
- Create a Firebase project in the console.
- Add an Android app with package name `com.ugo.mhews.mealmanage`.
- Download `google-services.json` and place it at `app/google-services.json` (replace if present).

3) Enable providers and services
- Authentication: enable Email/Password.
- Firestore: create a database (Production or Test mode as you prefer).

4) Apply security rules and indexes
- Rules: review `firestore.rules` and deploy to your project.
- Indexes: deploy `firestore.indexes.json` to enable collection‑group queries on `days.date`.
- Using Firebase CLI:
  - `firebase use <your-project-id>`
  - `firebase deploy --only firestore:rules`
  - `firebase deploy --only firestore:indexes`

5) Build & run
- From Android Studio: select a device and press Run.

## Testing

- Unit tests cover domain use cases, core providers, and app ViewModels.
- ViewModel tests use coroutines test utilities and a `MainDispatcherRule` for deterministic scheduling.
- Data layer is exercised at unit level via error mappers and isolated repository logic (no live network).

Run tests locally:
- All JVM tests + Android unit tests: `./gradlew :domain:test :core:test :data:testDebugUnitTest :app:testDebugUnitTest`
- Single module: `./gradlew :domain:test`

In CI:
- JUnit results are summarized in the job summary and (when permissions allow) in a Checks entry.

## Code Coverage

This repo uses the Kover plugin for coverage.

Generate XML coverage locally:
- `./gradlew koverXmlReport`
- Root XML: `build/reports/kover/report.xml`
- Enforced check (fails below 100% line coverage for measured sources): `./gradlew koverVerify`

HTML coverage:
- HTML generation is disabled in CI to avoid template rendering issues.
- If you want HTML locally, temporarily remove the lines disabling `koverHtmlReport` at the end of `build.gradle.kts` and run:
  - `./gradlew :domain:koverHtmlReport` (start with domain/core for quick iteration)
  - Open the generated `build/reports/kover/html/index.html` under the module.

Coverage scope and filters:
- UI composables, Activities, DI modules, and generated Hilt classes are excluded to focus on business logic and testable code paths.

## Continuous Integration

- GitHub Actions workflow: `.github/workflows/ci.yml`
  - Runs unit tests across modules in parallel with Gradle caching enabled.
  - Publishes a test results summary to the job summary (always visible).
  - Generates coverage XML and uploads as an artifact.
  - Updates a tests badge on the README (on `main` branch pushes).

- CLI: `./gradlew assembleDebug` (and install the APK on a device/emulator).

6) Sign up and sign in
- On first launch, use the Sign Up tab to create an account, then sign in.

## How the Meals Calendar Works

- Shows 6 weeks (42 days) covering the selected month.
- Badges appear on days where your meal count > 0.
- Colors: yellow for current/future days with meals, green for past days with meals, subtle highlight for today.
- Past days: opens a dialog listing all users’ counts.
- Current/future: opens an editor to increment/decrement and save your count.
- Data flows:
  - On month change, the screen proactively fetches the month’s meals.
  - A realtime listener keeps the calendar in sync; if it fails (e.g., indexing delay), a fallback one‑shot fetch runs and a snackbar shows the error.

## Troubleshooting

- Missing index (collection group `days`):
  - Symptom: Firestore error mentioning `FAILED_PRECONDITION` and an index requirement on `days` and `date`.
  - Fix: deploy indexes with `firebase deploy --only firestore:indexes`.

- No badges/colors visible:
  - Ensure you’re signed in and have saved a non‑zero meal count for some days.
  - The calendar auto‑loads on month change; a snackbar appears if realtime updates fail temporarily.

- Auth errors:
  - Rules require `request.auth != null`. Sign in first.
  - If using Test mode rules, consider tightening to the provided rules when you go to production.

- `google-services.json`:
  - Replace the included file with your own from Firebase. Avoid committing your project’s credentials to a public repo.

## Scripts

- `scripts/deploy_firestore_rules.sh` — example shell script to deploy Firestore rules (requires Firebase CLI).

## Contributing

- Branch from `main` (e.g., `feature/...`), open a Pull Request.
- Keep changes focused and include a short rationale in the PR description.

## Recent Changes

- Calendar badges reliability: proactive month load, resilient realtime listener, corrected Firestore queries for collection‑group ranges.
- please feel free to contribution 
